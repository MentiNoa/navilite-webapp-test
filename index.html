<!DOCTYPE html>
<html lang="it">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Navigatore GPS</title>
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script src="https://unpkg.com/osmtogeojson@3.0.0-beta.5/osmtogeojson.js"></script>
  <link rel="manifest" href="/navilite-webapp-test/manifest.json">
  <meta name="theme-color" content="#0f172a">
  <style>
    :root {
      --scale-factor: 1;
      --font-size-base: 16px;
      transition: font-size 0.3s ease, padding 0.3s ease, margin 0.3s ease, border-radius 0.3s ease;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    #map {
      position: absolute;
      inset: 0;
    }

    .controls,
    input[type="text"],
    button,
    #resultsList,
    #etaBox,
    #firmaVersione {
      font-size: var(--font-size-base);
      transition:
        font-size 0.3s ease,
        padding 0.3s ease,
        margin 0.3s ease,
        border-radius 0.3s ease;
    }

    .controls {
      position: absolute;
      top: 2vh;
      left: 2vw;
      z-index: 5;
      width: min(92vw, 420px);
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(6px);
      border-radius: calc(var(--scale-factor) * 1.5vh);
      box-shadow: 0 1vh 3vh rgba(0, 0, 0, 0.15);
      padding: calc(var(--scale-factor) * 1.2vh);
    }

    .row {
      display: flex;
      gap: calc(var(--scale-factor) * 1vh);
      align-items: center;
      flex-wrap: wrap;
    }

    input[type="text"] {
      flex: 1;
      padding: calc(var(--scale-factor) * 1vh) calc(var(--scale-factor) * 1.2vh);
      border-radius: calc(var(--scale-factor) * 1vh);
      border: 1px solid #ddd;
    }

    button {
      padding: calc(var(--scale-factor) * 1vh) calc(var(--scale-factor) * 1.2vh);
      border: none;
      border-radius: calc(var(--scale-factor) * 1vh);
      background: #4CAF50;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      z-index: 10;
    }

    button.secondary {
      background: #f0f2f5;
      color: #111;
    }

    button.warn {
      background: #e24a3b;
    }

    button.active {
      outline: calc(var(--scale-factor) * 0.2vh) solid #084ec8;
      background: #0847b7;
      color: #fff;
    }

    #installBtn {
      display: none;
      width: 100%;
      margin-top: calc(var(--scale-factor) * 1vh);
    }

    #resultsList {
      display: none;
      margin-top: calc(var(--scale-factor) * 1vh);
      max-height: 30vh;
      overflow: auto;
      border: 1px solid #e3e3e3;
      border-radius: calc(var(--scale-factor) * 1vh);
      background: #fff;
    }

    .result-item {
      padding: calc(var(--scale-factor) * 1vh) calc(var(--scale-factor) * 1.2vh);
      border-bottom: 1px solid #f2f2f2;
      cursor: pointer;
    }

    .result-item:last-child {
      border-bottom: none;
    }

    .result-item:hover {
      background: #f8fafc;
    }

    #etaBox {
      display: none;
      margin-top: calc(var(--scale-factor) * 1vh);
      padding: calc(var(--scale-factor) * 1vh) calc(var(--scale-factor) * 1.2vh);
      border-radius: calc(var(--scale-factor) * 1vh);
      background: #111;
      color: #fff;
      font-weight: 600;
    }

    @media (max-width: 640px) {
      .controls {
        width: calc(100vw - 2vh);
      }
    }

    #firmaVersione {
      position: fixed;
      bottom: 8px;
      left: 8px;
      margin: 8px;
      background: rgba(255, 255, 255, 0.8);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.85em;
      color: #666;
      z-index: 999;
    }
  </style>
  <script> function aggiornaScala() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      const diagonalePx = Math.sqrt(w * w + h * h);
      const dpi = window.devicePixelRatio * 96;
      const diagonalePollici = diagonalePx / dpi;

      let scaleFactor = diagonalePx / 1000;
      scaleFactor = Math.max(0.8, Math.min(scaleFactor, 2));

      const fontSizeBase = Math.max(12, Math.min(scaleFactor * 10, 22));

      document.documentElement.style.setProperty('--scale-factor', scaleFactor);
      document.documentElement.style.setProperty('--font-size-base', `${fontSizeBase}px`);

      console.log(`Diagonale: ${diagonalePx.toFixed(0)}px ~ ${diagonalePollici.toFixed(2)}\" | Scala: ${scaleFactor.toFixed(2)}`);
    }

    window.addEventListener('load', aggiornaScala);
    window.addEventListener('resize', aggiornaScala);

    // Reverse geocoding per rilevare comune
    // Reverse geocoding per rilevare comune e salvare coordinate
    window.addEventListener('load', () => {
      if (!navigator.geolocation) return;
      navigator.geolocation.getCurrentPosition(pos => {
        const { longitude: lng, latitude: lat } = pos.coords;

        // Salvo coordinate e comune attuale
        app.currentCoords = [lng, lat];

        fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json&addressdetails=1&accept-language=it`)
          .then(res => res.json())
          .then(data => {
            app.currentTown = data.address?.town || data.address?.city || data.address?.village || '';
            console.log('Comune rilevato:', app.currentTown, app.currentCoords);
          })
          .catch(err => console.warn('Reverse geocoding fallito:', err));
      }, err => console.warn('Geolocalizzazione fallita:', err), { enableHighAccuracy: true, timeout: 8000 });
    });


  </script>
</head>

<body>
  <div id="map"></div>

  <div class="controls">
    <div class="row">
      <input id="searchInput" type="text" placeholder="Cerca in Sardegna (via, luogo)..." autocomplete="off" />
      <button id="searchBtn" class="secondary">Cerca</button>
    </div>

    <div id="resultsList"></div>

    <div class="row" style="margin-top:8px; gap:8px;">
      <button id="goToSearchBtn">Vai a destinazione</button>
      <button id="followBtn" class="secondary">Segui posizione: Off</button>
      <button id="clearRouteBtn" class="warn">Annulla</button>
    </div>

    <button id="installBtn">?? Installa App</button>

    <div id="etaBox">Calcolo percorso...</div>
  </div>

  <div id="firmaVersione"> 2025 - v<span id="versionLabel"></span></div>

  <script>
    const APP_VERSION = '1.0.6';
    document.getElementById('versionLabel').textContent = APP_VERSION;
    console.log(`NaviLite - versione ${APP_VERSION} - � SM`);

    // Script del bottone installa app
    let deferredPrompt;

    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      document.getElementById('installBtn').style.display = 'block';
    });

    document.getElementById('installBtn').addEventListener('click', () => {
      if (deferredPrompt) {
        deferredPrompt.prompt();
        deferredPrompt.userChoice.then((choiceResult) => {
          console.log(choiceResult.outcome);
          deferredPrompt = null;
        });
      }
    });

    function riallineaFirma() {
      const credits = document.querySelector('.maplibregl-ctrl-attrib');
      const firma = document.getElementById('firmaVersione');

      if (credits && firma) {
        const rect = credits.getBoundingClientRect();
        const offset = window.innerHeight - rect.top;
        firma.style.bottom = `${offset}px`;
      }
    }

    window.addEventListener('load', riallineaFirma);
    window.addEventListener('resize', riallineaFirma);
  </script>


  <script>
    // --- App state ---
    const app = {
      map: null,
      startPoint: null,
      endPoint: null,
      userMarker: null,
      searchMarker: null,
      followMode: false,
      watchId: null,
      lastRouteUpdate: 0,
      routeFittedOnce: false,
      navigationActive: false,
      routeSourceId: 'route-src',
      routeLayerId: 'route-lyr',
      routeFeature: null
    };

    // --- Stile OpenStreetMap standard ---
    const STYLE_DEFAULT = {
      version: 8,
      sources: {
        "osm-tiles": {
          type: "raster",
          tiles: ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
          tileSize: 256,
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }
      },
      layers: [
        { id: "osm-tiles", type: "raster", source: "osm-tiles", minzoom: 0, maxzoom: 19 }
      ]
    };

    // --- Map init ---
    app.map = new maplibregl.Map({
      container: 'map',
      style: STYLE_DEFAULT,
      center: [9.014, 39.424],
      zoom: 7
    });
    app.map.addControl(new maplibregl.NavigationControl(), 'bottom-right');
    app.map.on('style.load', applyCustomLayers);

    // --- Utils ---
    function getDistanceMeters(a, b) {
      const R = 6371000, toRad = d => d * Math.PI / 180;
      const [lng1, lat1] = a, [lng2, lat2] = b;
      const dLat = toRad(lat2 - lat1), dLng = toRad(lng2 - lng1);
      const s = Math.sin(dLat / 2) ** 2 +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
        Math.sin(dLng / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(s));
    }

    function getReadableDistance(a, b) {
      const d = getDistanceMeters(a, b);
      return d < 1000 ? `${Math.round(d)} m` : `${(d / 1000).toFixed(1)} km`;
    }
    function updateETA(seconds) {
      const box = document.getElementById('etaBox');
      if (!seconds && seconds !== 0) {
        box.style.display = 'none';
        box.textContent = '';
        return;
      }
      const mins = Math.round(seconds / 60);
      const text = mins < 60 ? `${mins} min` : `${Math.floor(mins / 60)} h ${mins % 60} min`;
      // aggiunta distanza
      box.textContent = `Arrivo stimato: ${text} (${getReadableDistance(app.startPoint, app.endPoint)})`;
      box.style.display = 'block';
    }

    function fitRouteBounds(coords) {
      if (!coords?.length) return;
      let minX = coords[0][0], maxX = coords[0][0], minY = coords[0][1], maxY = coords[0][1];
      for (const [x, y] of coords) { if (x < minX) minX = x; if (x > maxX) maxX = x; if (y < minY) minY = y; if (y > maxY) maxY = y; }
      app.map.fitBounds([[minX, minY], [maxX, maxY]], { padding: 60, duration: 700 });
    }

    // --- Geolocalizzazione ---
    function updateUserPosition(centerMap = true) {
      if (!navigator.geolocation) return;
      navigator.geolocation.getCurrentPosition(pos => {
        const { longitude: lng, latitude: lat, heading } = pos.coords;
        app.startPoint = [lng, lat];

        if (app.userMarker) app.userMarker.setLngLat(app.startPoint);
        else {
          app.userMarker = new maplibregl.Marker({ color: '#d70000' })
            .setLngLat(app.startPoint)
            .setPopup(new maplibregl.Popup().setText('Posizione attuale'))
            .addTo(app.map);
        }

        if (centerMap || app.followMode) {
          app.map.easeTo({
            center: app.startPoint,
            zoom: Math.max(app.map.getZoom(), 15),
            bearing: (typeof heading === 'number' ? heading : app.map.getBearing()),
            pitch: 45,
            duration: 800,
            essential: true
          });
        }
      }, err => console.warn('Geolocalizzazione fallita:', err), { enableHighAccuracy: true, timeout: 8000 });
    }

    function startLiveTracking() {
      if (!navigator.geolocation) return;
      if (app.watchId) navigator.geolocation.clearWatch(app.watchId);

      app.watchId = navigator.geolocation.watchPosition(pos => {
        const { longitude: lng, latitude: lat, heading } = pos.coords;
        app.startPoint = [lng, lat];

        if (app.userMarker) app.userMarker.setLngLat(app.startPoint);
        else {
          app.userMarker = new maplibregl.Marker({ color: '#d70000' })
            .setLngLat(app.startPoint)
            .setPopup(new maplibregl.Popup().setText('Posizione attuale'))
            .addTo(app.map);
        }

        if (app.followMode) {
          app.map.easeTo({
            center: app.startPoint,
            zoom: Math.max(app.map.getZoom(), 15),
            bearing: (typeof heading === 'number' ? heading : app.map.getBearing()),
            pitch: 45,
            duration: 800,
            essential: true
          });
        }

        const now = Date.now();
        if (app.navigationActive && app.endPoint && now - app.lastRouteUpdate > 4000) {
          requestRoute(app.startPoint, app.endPoint);
          app.lastRouteUpdate = now;
        }
      }, err => console.warn('watchPosition errore:', err), {
        enableHighAccuracy: true,
        maximumAge: 2000,
        timeout: 10000
      });
    }

    window.addEventListener('load', () => {
      updateUserPosition(true);
      startLiveTracking();
    });
    window.addEventListener('beforeunload', () => {
      if (app.watchId) navigator.geolocation.clearWatch(app.watchId);
    });

    // --- Ricerca (Nominatim) ---
    function performSearch() {
      const query = document.getElementById('searchInput').value.trim();
      const resultsList = document.getElementById('resultsList');
      resultsList.innerHTML = '';
      resultsList.style.display = 'none';
      if (!query) return;

      // Aggiorna posizione e comune
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(pos => {
          const { longitude: lng, latitude: lat } = pos.coords;
          app.currentCoords = [lng, lat];

          // Aggiorna anche il comune per coerenza
          fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json&addressdetails=1&accept-language=it`)
            .then(res => res.json())
            .then(data => {
              app.currentTown = data.address?.town || data.address?.city || data.address?.village || '';
              console.log('Comune aggiornato:', app.currentTown);
              eseguiRicerca(query);
            })
            .catch(err => {
              console.warn('Reverse geocoding fallito:', err);
              eseguiRicerca(query);
            });
        }, err => {
          console.warn('Geo non riuscita, uso coords precedenti:', err);
          eseguiRicerca(query);
        }, { enableHighAccuracy: true, timeout: 8000 });
      } else {
        eseguiRicerca(query);
      }
    }

    function eseguiRicerca(query) {
      const resultsList = document.getElementById('resultsList');

      const params = new URLSearchParams({
        format: 'json',
        q: query,
        addressdetails: '1',
        limit: '8',
        'accept-language': 'it',
        countrycodes: 'it',
        viewbox: '8.1,41.4,9.8,38.8',
        bounded: '1'
      });

      fetch(`https://nominatim.openstreetmap.org/search?${params}`, {
        headers: { 'Accept': 'application/json' }
      })
        .then(res => res.json())
        .then(results => {
          if (!Array.isArray(results) || results.length === 0) {
            resultsList.style.display = 'block';
            const empty = document.createElement('div');
            empty.className = 'result-item';
            empty.textContent = 'Nessun risultato';
            resultsList.appendChild(empty);
            return;
          }

          const currentCoords = app.currentCoords;
          const currentTown = app.currentTown?.toLowerCase() || '';

          const enriched = results.map(place => {
            const lng = parseFloat(place.lon);
            const lat = parseFloat(place.lat);
            const comune = place.address?.town || place.address?.city || place.address?.village || place.address?.municipality || '';
            const comuneLower = comune.toLowerCase();
            const isComuneMatch = currentTown && comuneLower === currentTown;
            const distMeters = currentCoords ? getDistanceMeters(currentCoords, [lng, lat]) : null;
            const distText = distMeters !== null ? getReadableDistance(currentCoords, [lng, lat]) : '—';

            const item = document.createElement('div');
            item.className = 'result-item';
            item.innerHTML = `<strong>${place.display_name}</strong><br><small>Distanza: ${distText}</small>`;
            item.addEventListener('click', () => {
              app.endPoint = [lng, lat];
              app.navigationActive = false;
              app.routeFittedOnce = false;
              app.map.flyTo({ center: app.endPoint, zoom: 15 });
              if (app.searchMarker) app.searchMarker.remove();
              app.searchMarker = new maplibregl.Marker({ color: '#00aa00' })
                .setLngLat(app.endPoint)
                .setPopup(new maplibregl.Popup().setText('Destinazione'))
                .addTo(app.map);
              resultsList.style.display = 'none';
              document.getElementById('searchInput').blur();
            });

            return { item, distMeters, isComuneMatch };
          });

          enriched.sort((a, b) => {
            // Prima la distanza
            if (a.distMeters !== null && b.distMeters !== null && a.distMeters !== b.distMeters) {
              return a.distMeters - b.distMeters;
            }
            // A parità di distanza (entro 1 km), preferisci match di comune
            const nearA = a.distMeters !== null && a.distMeters <= 1000;
            const nearB = b.distMeters !== null && b.distMeters <= 1000;
            if (nearA && !nearB) return -1;
            if (!nearA && nearB) return 1;
            return 0;
          });


          enriched.forEach(r => resultsList.appendChild(r.item));
          resultsList.style.display = 'block';
        })
        .catch(err => console.error('Errore ricerca:', err));
    }

    let searchDebounce;
    document.getElementById('searchInput').addEventListener('input', () => {
      clearTimeout(searchDebounce);
      searchDebounce = setTimeout(performSearch, 300);
    });

    document.getElementById('searchBtn').addEventListener('click', performSearch);
    document.getElementById('searchInput').addEventListener('keypress', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        performSearch();
        document.getElementById('searchInput').blur();
      }
    });
    // --- Rotta (OSRM) ---
    function requestRoute(start, end) {
      if (!start || !end) return;
      const etaBox = document.getElementById('etaBox');
      etaBox.textContent = 'Calcolo percorso...';
      etaBox.style.display = 'block';

      const url = `https://router.project-osrm.org/route/v1/driving/${start.join(',')};${end.join(',')}?overview=full&geometries=geojson&alternatives=false&steps=true&annotations=duration,distance&continue_straight=true`;

      fetch(url)
        .then(res => res.json())
        .then(data => {
          if (!data.routes || data.routes.length === 0) {
            updateETA(null);
            alert('Percorso non trovato.');
            return;
          }
          const route = data.routes[0];
          app.routeFeature = { type: 'Feature', geometry: route.geometry, properties: {} };
          addOrUpdateRouteSource(app.routeFeature);

          if (!app.routeFittedOnce) {
            fitRouteBounds(route.geometry.coordinates);
            app.routeFittedOnce = true;
          }
          updateETA(route.duration);
        })
        .catch(err => {
          console.error('Errore nel calcolo del percorso:', err);
          updateETA(null);
          alert('Impossibile calcolare il percorso.');
        });
    }

    function addOrUpdateRouteSource(feature) {
      const src = app.map.getSource(app.routeSourceId);
      if (src) {
        src.setData(feature);
      } else {
        app.map.addSource(app.routeSourceId, { type: 'geojson', data: feature });
      }
      if (!app.map.getLayer(app.routeLayerId)) {
        app.map.addLayer({
          id: app.routeLayerId,
          type: 'line',
          source: app.routeSourceId,
          layout: { 'line-join': 'round', 'line-cap': 'round' },
          paint: { 'line-color': '#0077ff', 'line-width': 5 }
        });
      }
    }

    function applyCustomLayers() {
      if (app.routeFeature) {
        if (!app.map.getSource(app.routeSourceId)) {
          app.map.addSource(app.routeSourceId, { type: 'geojson', data: app.routeFeature });
        }
        if (!app.map.getLayer(app.routeLayerId)) {
          app.map.addLayer({
            id: app.routeLayerId,
            type: 'line',
            source: app.routeSourceId,
            layout: { 'line-join': 'round', 'line-cap': 'round' },
            paint: { 'line-color': '#0077ff', 'line-width': 5 }
          });
        }
      }
    }

    function clearRoute() {
      app.navigationActive = false;
      app.endPoint = null;
      app.lastRouteUpdate = 0;

      if (app.map.getLayer(app.routeLayerId)) app.map.removeLayer(app.routeLayerId);
      if (app.map.getSource(app.routeSourceId)) app.map.removeSource(app.routeSourceId);
      app.routeFeature = null;
      app.routeFittedOnce = false;
      if (app.searchMarker) { app.searchMarker.remove(); app.searchMarker = null; }
      updateETA(null);
    }

    // --- Wake Lock ---
    let wakeLock = null;

    async function attivaWakeLock() {
      try {
        wakeLock = await navigator.wakeLock.request('screen');
        console.log('Wake Lock attivato');
        wakeLock.addEventListener('release', () => {
          console.log('Wake Lock rilasciato');
        });
      } catch (err) {
        console.error('Impossibile attivare Wake Lock:', err);
      }
    }

    function disattivaWakeLock() {
      if (wakeLock) {
        wakeLock.release();
        wakeLock = null;
        console.log('Wake Lock disattivato manualmente');
      }
    }

    // --- Follow toggle unificato ---
    function toggleFollow() {
      app.followMode = !app.followMode;
      const btn = document.getElementById('followBtn');
      btn.textContent = `Segui posizione: ${app.followMode ? 'On' : 'Off'}`;
      btn.classList.toggle('active', app.followMode);

      if (app.followMode) {
        updateUserPosition(true);
        startLiveTracking();
      }
    }

    // --- Event wiring ---
    document.getElementById('goToSearchBtn').addEventListener('click', () => {
      if (!app.startPoint || !app.endPoint) {
        alert('Seleziona prima una destinazione.');
        return;
      }
      app.routeFittedOnce = false;
      app.navigationActive = true;
      requestRoute(app.startPoint, app.endPoint);

      if ('wakeLock' in navigator) attivaWakeLock();

    });

    document.getElementById('clearRouteBtn').addEventListener('click', () => {
      clearRoute();
      disattivaWakeLock();
    });
    document.getElementById('followBtn').addEventListener('click', toggleFollow);

    document.addEventListener('click', (e) => {
      const resultsList = document.getElementById('resultsList');
      if (!resultsList.contains(e.target) && e.target.id !== 'searchInput') {
        resultsList.style.display = 'none';
      }
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') document.getElementById('resultsList').style.display = 'none';
    });
    // --- Confini Villasor ---
    function addVillasorBorders() {
      // URL Overpass API per poligono confini del comune di Villasor
      const overpassUrl = 'https://overpass-api.de/api/interpreter?data=' +
        encodeURIComponent(`
      [out:json];
      relation["boundary"="administrative"]["name"="Biddesorris/Villasor"];
      out geom;
    `);

      fetch(overpassUrl)
        .then(res => res.json())
        .then(osmData => {
          const geojson = osmtogeojson(osmData);
          if (!geojson.features.length) {
            console.warn("Confini di Villasor non trovati");
            return;
          }
          const borderId = 'villasor-borders';

          if (!app.map.getSource(borderId)) {
            app.map.addSource(borderId, { type: 'geojson', data: geojson });
          }

          if (!app.map.getLayer(borderId)) {
            app.map.addLayer({
              id: borderId,
              type: 'line',
              source: borderId,
              paint: { 'line-color': '#ff0000', 'line-width': 2 }
            });
            app.map.addLayer({
              id: borderId + '-fill',
              type: 'fill',
              source: borderId,
              paint: { 'fill-color': '#ff0000', 'fill-opacity': 0.0 }
            });
          }

          //Centra mappa sui confini
          const coords = geojson.features[0].geometry.coordinates.flat(2)
            .map(([lng, lat]) => [lng, lat]);
          fitRouteBounds(coords);
        })
        .catch(err => console.error('Errore nel caricamento confini Villasor:', err));
    }

    //Aggiungiamo i confini quando la mappa � pronta
    app.map.on('load', () => {
      addVillasorBorders();

    });


    // Config long press to marker destinazione + googlemaps share

    const LONG_PRESS_MS = 550;
    const MOVE_THRESHOLD_PX = 10;

    // Stato
    let pressTimer = null;
    let startPoint = null;     // [x, y] in pixel
    let startLngLat = null;    // [lng, lat]
    let pressMoved = false;

    // Listener generici
    function onPressStart(e) {
      clearTimeout(pressTimer);
      pressMoved = false;
      if (!e.point || !e.lngLat) return;
      startPoint = [e.point.x, e.point.y];
      startLngLat = [e.lngLat.lng, e.lngLat.lat];

      pressTimer = setTimeout(() => {
        if (!pressMoved && startLngLat) {
          setDestinationFromLongPress(startLngLat);
        }
      }, LONG_PRESS_MS);
    }

    function onPressMove(e) {
      if (!startPoint || !e.point) return;
      const dx = e.point.x - startPoint[0];
      const dy = e.point.y - startPoint[1];
      if (Math.hypot(dx, dy) > MOVE_THRESHOLD_PX) {
        pressMoved = true;
        clearTimeout(pressTimer);
      }
    }

    function onPressEnd() {
      clearTimeout(pressTimer);
      pressTimer = null;
      startPoint = null;
      startLngLat = null;
    }

    // Collega mouse e touch
    app.map.on('mousedown', onPressStart);
    app.map.on('mousemove', onPressMove);
    app.map.on('mouseup', onPressEnd);

    app.map.on('touchstart', onPressStart);
    app.map.on('touchmove', onPressMove);
    app.map.on('touchend', onPressEnd);

    // Se parte un drag, annulla il long-press
    app.map.on('dragstart', () => {
      pressMoved = true;
      clearTimeout(pressTimer);
    });

    // Imposta destinazione e copia link
    function setDestinationFromLongPress(coords) {
      // Imposta destinazione
      app.endPoint = coords;
      app.navigationActive = false; // la rotta partir� solo con "Vai a destinazione"
      if (app.searchMarker) app.searchMarker.remove();
      app.searchMarker = new maplibregl.Marker({ color: '#00aa00' })
        .setLngLat(app.endPoint)
        .setPopup(new maplibregl.Popup().setText('Destinazione'))
        .addTo(app.map);

      // Copia link
      const url = `https://maps.google.com/?q=${coords[1]},${coords[0]}`;
      copyToClipboard(url).then(() => showToast('Posizione copiata'));
    }

    // Clipboard con fallback
    async function copyToClipboard(text) {
      if (navigator.clipboard && window.isSecureContext) {
        return navigator.clipboard.writeText(text);
      } else {
        return fallbackCopyText(text);
      }
    }

    function fallbackCopyText(text) {
      return new Promise((resolve, reject) => {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.top = '-9999px';
        ta.setAttribute('readonly', '');
        document.body.appendChild(ta);
        ta.select();
        ta.setSelectionRange(0, ta.value.length);
        const ok = document.execCommand('copy');
        document.body.removeChild(ta);
        ok ? resolve() : reject();
      });
    }

    // Toast "posizione copiata"
    function showToast(message, duration = 2000) {
      let toast = document.createElement('div');
      toast.textContent = message;
      toast.style.position = 'fixed';
      toast.style.left = '50%';
      toast.style.bottom = '24px';
      toast.style.transform = 'translateX(-50%)';
      toast.style.background = 'rgba(20,20,20,0.9)';
      toast.style.color = '#fff';
      toast.style.padding = '10px 14px';
      toast.style.borderRadius = '8px';
      toast.style.fontSize = '14px';
      toast.style.zIndex = '99999';
      toast.style.pointerEvents = 'none';
      toast.style.opacity = '0';
      toast.style.transition = 'opacity 150ms ease';
      document.body.appendChild(toast);
      requestAnimationFrame(() => (toast.style.opacity = '1'));
      setTimeout(() => {
        toast.style.opacity = '0';
        toast.addEventListener('transitionend', () => toast.remove(), { once: true });
      }, duration);
    }

  </script>

  <script src="/navilite-webapp/sw-register.js"></script>

</body>

</html>